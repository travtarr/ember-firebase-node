{
  "name": "letsencrypt-express",
  "version": "1.1.3",
  "description": "Free SSL and Automatic HTTPS for node.js with Express, Connect, and other middleware systems",
  "main": "index.js",
  "bin": {
    "letsencrypt-express": "bin/lex.js",
    "lex": "bin/lex.js"
  },
  "files": [
    "lib/",
    "bin/",
    "examples/",
    "index.js"
  ],
  "directories": {
    "example": "examples"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Daplie/letsencrypt-express.git"
  },
  "keywords": [
    "acme",
    "free",
    "ssl",
    "tls",
    "https",
    "letsencrypt",
    "le",
    "boulder",
    "express",
    "expressjs",
    "connect",
    "middleware"
  ],
  "author": {
    "name": "AJ ONeal",
    "email": "coolaj86@gmail.com",
    "url": "https://coolaj86.com/"
  },
  "license": "(MIT OR Apache-2.0)",
  "bugs": {
    "url": "https://github.com/Daplie/letsencrypt-express/issues"
  },
  "homepage": "https://github.com/Daplie/letsencrypt-express#readme",
  "devDependencies": {
    "body-parser": "^1.14.2",
    "cli": "^0.11.1",
    "express": "^4.13.3"
  },
  "dependencies": {
    "homedir": "^0.6.0",
    "letsencrypt": "^1.4.2",
    "localhost.daplie.com-certificates": "^1.1.2",
    "mkdirp": "^0.5.1"
  },
  "readme": "# LetsEncrypt Express\n\nFree SSL and managed or automatic HTTPS for node.js with Express, Koa, Connect, Hapi, and all other middleware systems.\n\n* Automatic Registration via SNI (`httpsOptions.SNICallback`)\n  * **registrations** require an **approval callback** in *production*\n* Automatic Renewal (around 80 days)\n  * **renewals** are *fully automatic* and happen in the *background*, with **no downtime**\n* Automatic vhost / virtual hosting\n\nAll you have to do is start the webserver and then visit it at it's domain name.\n\n## Install\n\n```\nnpm install --save letsencrypt-express\n```\n\n## Usage\n\n* standalone\n* express\n* http / https\n* http / http2 / spdy\n* koa\n\n### Setup (same for all examples) \n\n```javascript\n'use strict';\n\n/* Note: using staging server url, remove .testing() for production\nUsing .testing() will overwrite the debug flag with true */ \nvar LEX = require('letsencrypt-express').testing();\n\nvar lex = LEX.create({\n  configDir: require('os').homedir() + '/letsencrypt/etc'\n, approveRegistration: function (hostname, cb) { // leave `null` to disable automatic registration\n    // Note: this is the place to check your database to get the user associated with this domain\n    cb(null, {\n      domains: [hostname]\n    , email: 'CHANGE_ME' // user@example.com\n    , agreeTos: true\n    });\n  }\n});\n```\n\nWARNING: If you don't do any checks and simply complete `approveRegistration` callback, an attacker will spoof SNI packets with bad hostnames and that will cause you to be rate-limited and or blocked from the ACME server. Alternatively, You can run registration *manually*:\n\n```bash\nnpm install -g letsencrypt-cli\n\nletsencrypt certonly --standalone \\\n  --config-dir ~/letsencrypt/etc \\\n  --agree-tos --domains example.com --email user@example.com\n  \n# Note: the '--webrootPath' option is also available if you don't want to shut down your webserver to get the cert.\n```\n\n### Standalone\n\n```javascript\nlex.onRequest = function (req, res) {\n  res.end('Hello, World!');\n};\n\nlex.listen([80], [443, 5001], function () {\n  console.log(\"ENCRYPT __ALL__ THE DOMAINS!\");\n});\n\n// NOTE:\n// `~/letsencrypt/etc` is the default `configDir`\n// ports 80, 443, and 5001 are the default ports to listen on.\n```\n\n## Express\n\n```bash\nnpm install --save spdy\n```\n\n```javascript\n// A happy little express app\nvar app = require('express')();\n\napp.use(function (req, res) {\n  res.send({ success: true });\n});\n\nlex.onRequest = app;\n\nlex.listen([80], [443, 5001], function () {\n  var protocol = ('requestCert' in this) ? 'https': 'http';\n  console.log(\"Listening at \" + protocol + '://localhost:' + this.address().port);\n});\n```\n\n### Use with raw http / https modules\n\nLet's say you want to redirect all http to https.\n\n```javascript\nvar http = require('http');\nvar https = require('spdy');\n// NOTE: you could use the old https module if for some reason you don't want to support modern browsers\n\nfunction redirectHttp() {\n  http.createServer(LEX.createAcmeResponder(lex, function redirectHttps(req, res) {\n    res.setHeader('Location', 'https://' + req.headers.host + req.url);\n    res.end('<!-- Hello Developer Person! Please use HTTPS instead -->');\n  })).listen(80);\n}\n\nfunction serveHttps() {\n  var app = require('express')();\n  \n  app.use('/', function (req, res) {\n    res.end('Hello!');\n  });\n  \n  https.createServer(lex.httpsOptions, LEX.createAcmeResponder(lex, app)).listen(443);\n}\n\nredirectHttp();\nserveHttps();\n```\n\n### Let's Encrypt with Koa\n\n```javascript\nvar http = require('http');\nvar https = require('spdy');       // Note: some have reported trouble with `http2` and success with `spdy`\nvar koa = require('koa');\nvar app = koa();\nvar redirectHttps = koa().use(require('koa-force-ssl').callback();\n\napp.use(function *() {\n  this.body = 'Hello World';\n});\n\nvar server = https.createServer(lex.httpsOptions, LEX.createAcmeResponder(lex, app.callback()));\nvar redirectServer = http.createServer(LEX.createAcmeResponder(lex, redirectHttps)));\n\nserver.listen(443, function () {\n console.log('Listening at https://localhost:' + this.address().port);\n});\n\nredirectServer.listen(80, function () {\n  console.log('Redirecting insecure traffic from http://localhost:' + this.address().port + ' to https');\n});\n```\n\n### WebSockets with Let's Encrypt\n\nNote: you don't need to create websockets for the plain ports.\n\n```javascript\nvar WebSocketServer = require('ws').Server;\nvar https = require('spdy');\nvar server = https.createServer(lex.httpsOptions, LEX.createAcmeResponder(lex, app));\nvar wss = new WebSocketServer({ server: server });\n\nwss.on('connection', onConnection);\nserver.listen(443);\n\nfunction onConnection(ws) {\n  var location = url.parse(ws.upgradeReq.url, true);\n  // you might use location.query.access_token to authenticate or share sessions\n  // or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)\n\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n  });\n\n  ws.send('something');\n}\n```\n\n## API\n\n```\n                                // checks options and sets up defaults. returns object with `listen`\nLEX.create(options)             // (it was really just done this way to appeal to what people are used to seeing)\n\n  lex.listen(plain, tls, fn)    // actually creates the servers and causes them to listen\n\n\n                                // receives an instance of letsencrypt, returns an SNICallback handler for https.createServer()\nLEX.createSniCallback(opts)     // this will call letsencrypt.renew and letsencrypt.register as appropriate\n                                // it will randomly stagger renewals such that they don't all happen at once on boot\n                                // or at any other time. registrations will be handled as per `handleRegistration`\n  opts = {\n    letsencrypt: <obj>          // letsencrypt instance\n  , memorizeFor: <1 day>        // how long to wait before checking the disk for updated certificates\n  , renewWithin: <3 days>       // the first possible moment the certificate staggering should begin\n  , failedWait:  <5 minutes>    // how long to wait before trying again if the certificate registration failed\n\n\n                                // registrations are NOT approved automatically by default due to security concerns\n  , approveRegistration: func   // (someone can spoof servername indication to your server and cause you to be rate-limited)\n                                // but you can implement handling of them if you wish\n                                // (note that you should probably call the callback immediately with a tlsContext)\n                                //\n                                // default    function (hostname, cb) { cb(null, null); }\n                                //\n                                // example    function (hostname, cb) {\n                                //              cb(null, { domains: [hostname], agreeTos: true, email: 'user@example.com' });\n                                //            }\n\n\n  , handleRenewFailure: func    // renewals are automatic, but sometimes they may fail. If that happens, you should handle it\n                                // (note that renewals happen in the background)\n                                //\n                                // default    function (err, letsencrypt, hostname, certInfo) {}\n  }\n\n\n                                // uses `opts.webrootPath` to read from the filesystem\nLEX.getChallenge(opts, hostname, key cb)\n\nLEX.createAcmeResponder(opts, fn)  // this will return the necessary request handler for /.well-known/acme-challenges\n                                   // which then calls `fn` (such as express app) to complete the request\n                                   //\n                                   // opts     lex instance created with LEX.create(opts)\n                                   //         more generally, any object with a compatible `getChallenge` will work:\n                                   //         `lex.getChallenge(opts, domain, key, function (err, val) {})`\n                                   //\n                                   // fn       function (req, res) {\n                                   //            console.log(req.method, req.url);\n                                   //\n                                   //            res.end('Hello!');\n                                   //          }\n```\n\n## Options\n\nIf any of these values are `undefined` or `null` the will assume use reasonable defaults.\n\nPartially defined values will be merged with the defaults.\n\nSetting the value to `false` will, in many cases (as documented), disable the defaults.\n\n```\nconfigDir: string               // string     the letsencrypt configuration path (de facto /etc/letsencrypt)\n                                //\n                                // default    os.homedir() + '/letsencrypt/etc'\n\n\nwebrootPath: string             // string     a path to a folder where temporary challenge files will be stored and read\n                                //\n                                // default    os.tmpdir() + '/acme-challenge'\n\n\ngetChallenge: func | false      // false      do not handle getChallenge\n                                //\n                                // func       Example:\n                                //\n                                // default    function (defaults, hostname, key, cb) {\n                                //              var filename = path.join(defaults.webrootPath.replace(':hostname', hostname), key);\n                                //              fs.readFile(filename, 'ascii', function (cb, text) {\n                                //                cb(null, text);\n                                //              })\n                                //            }\n\n\nhttpsOptions: object            // object     will be merged with internal defaults and passed to https.createServer()\n                                //            { pfx, key, cert, passphrase, ca, ciphers, rejectUnauthorized, secureProtocol }\n                                //            See https://nodejs.org/api/https.html\n                                //            Note: if SNICallback is specified, it will be run *before*\n                                //            the internal SNICallback that manages automated certificates\n                                //\n                                // default    uses a localhost cert and key to prevent https.createServer() from throwing an error\n                                //            and also uses our SNICallback, which manages certificates\n\n\nsniCallback: func               // func       replace the default sniCallback handler (which manages certificates) with your own\n\n\nletsencrypt: object             // object     configure the letsencrypt object yourself and pass it in directly\n                                //\n                                // default    we create the letsencrypt object using parameters you specify\n\nserver: url                     // url        use letsencrypt.productionServerUrl (i.e. https://acme-v01.api.letsencrypt.org/directory)\n                                //            or letsencrypt.stagingServerUrl     (i.e. https://acme-staging.api.letsencrypt.org/directory)\n                                //\n                                // default    production\n```\n\n## More Examples\n\n### < 140 Characters\n\nLet's Encrypt in 128 characters, with spaces!\n\n```\nnode -e 'require(\"letsencrypt-express\").testing().create( require(\"express\")().use(function (_, r) { r.end(\"Hi!\") }) ).listen()'\n```\n\n### More realistic\n\n```javascript\n'use strict';\n\n// Note: using staging server url, remove .testing() for production\nvar LEX = require('letsencrypt-express').testing();\nvar express = require('express');\nvar app = express();\n\napp.use('/', function (req, res) {\n  res.send({ success: true });\n});\n\nLEX.create({\n  configDir: './letsencrypt.config'                 // ~/letsencrypt, /etc/letsencrypt, whatever you want\n\n, onRequest: app                                    // your express app (or plain node http app)\n\n, letsencrypt: null                                 // you can provide you own instance of letsencrypt\n                                                    // if you need to configure it (with an agreeToTerms\n                                                    // callback, for example)\n\n, approveRegistration: function (hostname, cb) {    // PRODUCTION MODE needs this function, but only if you want\n                                                    // automatic registration (usually not necessary)\n                                                    // renewals for registered domains will still be automatic\n    cb(null, {\n      domains: [hostname]\n    , email: 'user@example.com'\n    , agreeTos: true              // you\n    });\n  }\n}).listen([80], [443, 5001], function () {\n  console.log(\"ENCRYPT __ALL__ THE DOMAINS!\");\n});\n```\n\n### More Options Exposed\n\n```javascript\n'use strict';\n\nvar lex = require('letsencrypt-express');\nvar express = require('express');\nvar app = express();\n\napp.use('/', function (req, res) {\n  res.send({ success: true });\n});\n\nvar results = lex.create({\n  configDir: '/etc/letsencrypt'\n, onRequest: app\n, server: require('letsencrypt').productionServerUrl\n}).listen(\n\n  // you can give just the port, or expand out to the full options\n  [80, { port: 8080, address: 'localhost', onListening: function () { console.log('http://localhost'); } }]\n\n  // you can give just the port, or expand out to the full options\n, [443, 5001, { port: 8443, address: 'localhost' }]\n\n  // this is pretty much the default onListening handler\n, function onListening() {\n    var server = this;\n    var protocol = ('requestCert' in server) ? 'https': 'http';\n    console.log(\"Listening at \" + protocol + '://localhost:' + this.address().port);\n  }\n);\n\n// In case you need access to the raw servers (i.e. using websockets)\nconsole.log(results.plainServers);\nconsole.log(results.tlsServers);\n```\n\n\n### All Options Exposed\n\nHere's absolutely every option and function exposed\n\n```javascript\nvar http = require('http');\nvar https = require('spdy');\nvar LEX = require('letsencrypt-express');\nvar LE = require('letsencrypt');\nvar lex;\n\nlex = LEX.create({\n  webrootPath: '/tmp/.well-known/acme-challenge'\n\n, lifetime: 90 * 24 * 60 * 60 * 1000    // expect certificates to last 90 days\n, failedWait: 5 * 60 * 1000             // if registering fails wait 5 minutes before trying again\n, renewWithin: 3 * 24 * 60 * 60 * 1000  // renew at least 3 days before expiration\n, memorizeFor: 1 * 24 * 60 * 60 * 1000  // keep certificates in memory for 1 day\n\n, approveRegistration: function (hostname, cb) {\n    cb(null, {\n      domains: [hostname]\n    , email: 'user@example.com'\n    , agreeTos: true\n    });\n  }\n\n, handleRenewFailure: function (err, hostname, certInfo) {\n    console.error(\"ERROR: Failed to renew domain '\", hostname, \"':\");\n    if (err) {\n      console.error(err.stack || err);\n    }\n    if (certInfo) {\n      console.error(certInfo);\n    }\n  }\n\n, letsencrypt: LE.create(\n    // options\n    { configDir: './letsencrypt.config'\n    , manual: true\n\n    , server: LE.productionServerUrl\n    , privkeyPath: LE.privkeyPath\n    , fullchainPath: LE.fullchainPath\n    , certPath: LE.certPath\n    , chainPath: LE.chainPath\n    , renewalPath: LE.renewalPath\n    , accountsDir: LE.accountsDir\n\n    , debug: false\n    }\n\n    // handlers\n  , { setChallenge: LEX.setChallenge\n    , removeChallenge: LEX.removeChallenge\n    }\n  )\n\n, debug: false\n});\n\nhttp.createServer(LEX.createAcmeResponder(lex, function (req, res) {\n  res.setHeader('Location', 'https://' + req.headers.host + req.url);\n  res.end('<!-- Hello Mr Developer! Please use HTTPS instead -->');\n}));\n\nhttps.createServer(lex.httpsOptions, LEX.createAcmeResponder(lex, function (req, res) {\n  res.end('Hello!');\n}));\n```\n\n## Heroku?\n\nThis doesn't work on heroku because heroku uses a proxy with built-in https\n(which is a smart thing to do) and besides, they want you to pay big bucks\nfor https. (hopefully not for long?...)\n",
  "readmeFilename": "README.md",
  "_id": "letsencrypt-express@1.1.3",
  "dist": {
    "shasum": "caab47f1f0f0bc3acc336771a601903bee85c1bc"
  },
  "_from": "letsencrypt-express@",
  "_resolved": "https://registry.npmjs.org/letsencrypt-express/-/letsencrypt-express-1.1.3.tgz"
}
