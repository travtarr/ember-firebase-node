{
  "name": "letiny-core",
  "version": "1.0.5",
  "description": "A framework for building letsencrypt clients, forked from letiny",
  "main": "node.js",
  "browser": "browser.js",
  "directories": {
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "node example/letsencrypt.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Daplie/letiny-core.git"
  },
  "license": "MPL-2.0",
  "bugs": {
    "url": "https://github.com/Daplie/letiny-core/issues"
  },
  "homepage": "https://github.com/Daplie/letiny-core#readme",
  "keywords": [
    "tiny",
    "acme",
    "letsencrypt",
    "client",
    "pem",
    "pfx"
  ],
  "dependencies": {
    "node-forge": "^0.6.38",
    "request": "^2.55.0",
    "ursa": "^0.9.1"
  },
  "optionalDependencies": {
    "ursa": "^0.9.1"
  },
  "devDependencies": {
    "mocha": "^2.3.3",
    "better-assert": "^1.0.2"
  },
  "contributors": [
    {
      "name": "ISRG"
    },
    {
      "name": "Anatol Sommer",
      "email": "anatol@anatol.at"
    },
    {
      "name": "AJ ONeal",
      "email": "aj@daplie.com",
      "url": "https://daplie.com/"
    }
  ],
  "readme": "# letiny-core\n\nA framework for building letsencrypt clients, forked from `letiny`.\n\nSupports all of:\n\n  * node with `ursa` (works fast)\n  * node with `forge` (works on windows)\n  * browser WebCrypto (not implemented, but... Let's Encrypt over WebRTC anyone?)\n  * any javascript implementation\n\n### These aren't the droids you're looking for\n\nThis is a library / framework for building letsencrypt clients.\nYou probably want one of these pre-built clients instead:\n\n  * [`letsencrypt`](https://github.com/Daplie/node-letsencrypt) (compatible with the official client)\n  * `letiny` (lightweight client cli)\n  * [`letsencrypt-express`](https://github.com/Daplie/letsencrypt-express) (automatic https for express)\n\n## Install & Usage:\n\n```bash\nnpm install --save letiny-core\n```\n\nYou will follow these steps to obtain certificates:\n\n* discover ACME registration urls with `getAcmeUrls`\n* register a user account with `registerNewAccount`\n* implement a method to agree to the terms of service as `agreeToTos`\n* get certificates with `getCertificate`\n* implement a method to store the challenge token as `setChallenge`\n* implement a method to get the challenge token as `getChallenge`\n* implement a method to remove the challenge token as `removeChallenge`\n\n### Demo\n\nYou can see this working for yourself, but you'll need to be on an internet connected computer with a domain.\n\nGet a temporary domain for testing\n\n```bash\nnpm install -g ddns-cli\nddns --random --email user@example.com --agree\n```\n\nNote: use **YOUR EMAIL** and accept the terms of service (run `ddns --help` to see them).\n\n<!-- TODO tutorial on ddns -->\n\nInstall letiny-core and its dependencies. **Note**: it's okay if you're on windows\nand `ursa` fails to compile. It'll still work.\n\n```bash\ngit clone https://github.com/Daplie/letiny-core.git ~/letiny-core\npushd ~/letiny-core\n\nnpm install\n```\n\nRun the demo:\n\n```bash\nnode examples/letsencrypt.js user@example.com example.com\n```\n\nNote: use **YOUR TEMPORARY DOMAIN** and **YOUR EMAIL**.\n\n## API\n\nThe Goodies\n\n```javascript\n// Accounts\nLeCore.registerNewAccount(options, cb)        // returns \"regr\" registration data\n\n    { newRegUrl: '<url>'                      //    no defaults, specify acmeUrls.newAuthz\n    , email: '<email>'                        //    valid email (server checks MX records)\n    , accountPrivateKeyPem: '<ASCII PEM>'     //    callback to allow user interaction for tosUrl\n    , agreeToTerms: fn (tosUrl, cb) {}        //    must specify agree=tosUrl to continue (or falsey to end)\n    }\n\n// Registration\nLeCore.getCertificate(options, cb)            // returns (err, pems={ key, cert, ca })\n\n    { newAuthzUrl: '<url>'                    //    specify acmeUrls.newAuthz\n    , newCertUrl: '<url>'                     //    specify acmeUrls.newCert\n\n    , domainPrivateKeyPem: '<ASCII PEM>'\n    , accountPrivateKeyPem: '<ASCII PEM>'\n    , domains: ['example.com']\n\n    , setChallenge: fn (hostname, key, val, cb)\n    , removeChallenge: fn (hostname, key, cb)\n    }\n    \n// Discovery URLs\nLeCore.getAcmeUrls(acmeDiscoveryUrl, cb)      // returns (err, acmeUrls={newReg,newAuthz,newCert,revokeCert})\n```\n\nHelpers & Stuff\n\n```javascript\n// Constants\nLeCore.productionServerUrl                // https://acme-v01.api.letsencrypt.org/directory\nLeCore.stagingServerUrl                   // https://acme-staging.api.letsencrypt.org/directory\nLeCore.acmeChallengePrefix                // /.well-known/acme-challenge/\nLeCore.configDir                          // /etc/letsencrypt/\nLeCore.logsDir                            // /var/log/letsencrypt/\nLeCore.workDir                            // /var/lib/letsencrypt/\nLeCore.knownEndpoints                     // new-authz, new-cert, new-reg, revoke-cert\n\n\n// HTTP Client Helpers\nLeCore.Acme                               // Signs requests with JWK\n    acme = new Acme(lePrivateKey)           // privateKey format is abstract\n    acme.post(url, body, cb)                // POST with signature\n    acme.parseLinks(link)                   // (internal) parses 'link' header\n    acme.getNonce(url, cb)                  // (internal) HEAD request to get 'replay-nonce' strings\n\n// Note: some of these are not async,\n// but they will be soon. Don't rely\n// on their API yet.\n\n// Crypto Helpers\nLeCore.leCrypto\n    generateRsaKeypair(bitLen, exponent, cb);     // returns { privateKeyPem, privateKeyJwk, publicKeyPem, publicKeyMd5 }\n    thumbprint(lePubKey)                          // generates public key thumbprint\n    generateSignature(lePrivKey, bodyBuf, nonce)  // generates a signature\n    privateJwkToPems(jwk)                         // { n: '...', e: '...', iq: '...', ... } to PEMs\n    privatePemToJwk                               // PEM to JWK (see line above)\n    importPemPrivateKey(privateKeyPem)            // (internal) returns abstract private key\n```\n\nFor testing and development, you can also inject the dependencies you want to use:\n\n```javascript\nLeCore = LeCore.create({\n  request: require('request')\n, leCrypto: rquire('./lib/letsencrypt-forge')\n});\n\n// now uses node `request` (could also use jQuery or Angular in the browser)\nLeCore.getAcmeUrls(discoveryUrl, function (err, urls) {\n  console.log(urls);\n});\n```\n\n## Example\n\nBelow you'll find a stripped-down example. You can see the full example in the example folder.\n\n* [example/](https://github.com/Daplie/letiny-core/blob/master/example/)\n\n#### Register Account & Domain\n\nThis is how you **register an ACME account** and **get an HTTPS certificate**\n\n```javascript\n'use strict';\n\nvar LeCore = require('letiny-core');\n\nvar email = 'user@example.com';                   // CHANGE TO YOUR EMAIL\nvar domains = 'example.com';                      // CHANGE TO YOUR DOMAIN\nvar acmeDiscoveryUrl = LeCore.stagingServerUrl;   // CHANGE to production, when ready\n\nvar accountPrivateKeyPem = null;\nvar domainPrivateKeyPem = null;\nvar acmeUrls = null;\n\nLeCore.leCrypto.generateRsaKeypair(2048, 65537, function (err, pems) {\n    // ...\n    LeCore.getAcmeUrls(acmeDiscoveryUrl, function (err, urls) {\n        // ...\n        runDemo();\n    });\n});\n\nfunction runDemo() {\n    LeCore.registerNewAccount(\n        { newRegUrl: acmeUrls.newReg\n        , email: email\n        , accountPrivateKeyPem: accountPrivateKeyPem\n        , agreeToTerms: function (tosUrl, done) {\n\n              // agree to the exact version of these terms\n              done(null, tosUrl);\n          }\n        }\n      , function (err, regr) {\n\n            LeCore.getCertificate(\n                { newAuthzUrl: acmeUrls.newAuthz\n                , newCertUrl: acmeUrls.newCert\n\n                , domainPrivateKeyPem: domainPrivateKeyPem\n                , accountPrivateKeyPem: accountPrivateKeyPem\n                , domains: domains\n\n                , setChallenge: challengeStore.set\n                , removeChallenge: challengeStore.remove\n                }\n              , function (err, certs) {\n\n                  // Note: you should save certs to disk (or db)\n                  certStore.set(domains[0], certs, function () {\n\n                      // ...\n\n                  });\n\n                }\n            );\n        }\n    );\n}\n```\n\n**But wait**, there's more!\nSee [example/letsencrypt.js](https://github.com/Daplie/letiny-core/blob/master/example/letsencrypt.js)\n\n#### Run a Server on 80, 443, and 5001 (https/tls)\n\nThat will fail unless you have a webserver running on 80 and 443 (or 5001)\nto respond to `/.well-known/acme-challenge/xxxxxxxx` with the proper token\n\n```javascript\nvar https = require('https');\nvar http = require('http');\n\n\nvar LeCore = deps.LeCore;\nvar httpsOptions = deps.httpsOptions;\nvar challengeStore = deps.challengeStore;\nvar certStore = deps.certStore;\n\n\n//\n// Challenge Handler\n//\nfunction acmeResponder(req, res) {\n  if (0 !== req.url.indexOf(LeCore.acmeChallengePrefix)) {\n    res.end('Hello World!');\n    return;\n  }\n\n  var key = req.url.slice(LeCore.acmeChallengePrefix.length);\n\n  challengeStore.get(req.hostname, key, function (err, val) {\n    res.end(val || 'Error');\n  });\n}\n\n\n//\n// Server\n//\nhttps.createServer(httpsOptions, acmeResponder).listen(5001, function () {\n  console.log('Listening https on', this.address());\n});\nhttp.createServer(acmeResponder).listen(80, function () {\n  console.log('Listening http on', this.address());\n});\n```\n\n**But wait**, there's more!\nSee [example/serve.js](https://github.com/Daplie/letiny-core/blob/master/example/serve.js)\n\n#### Put some storage in place\n\nFinally, you need an implementation of `challengeStore`:\n\n```javascript\nvar challengeCache = {};\nvar challengeStore = {\n  set: function (hostname, key, value, cb) {\n    challengeCache[key] = value;\n    cb(null);\n  }\n, get: function (hostname, key, cb) {\n    cb(null, challengeCache[key]);\n  }\n, remove: function (hostname, key, cb) {\n    delete challengeCache[key];\n    cb(null);\n  }\n};\n\nvar certCache = {};\nvar certStore = {\n  set: function (hostname, certs, cb) {\n    certCache[hostname] = certs;\n    cb(null);\n  }\n, get: function (hostname, cb) {\n    cb(null, certCache[hostname]);\n  }\n, remove: function (hostname, cb) {\n    delete certCache[hostname];\n    cb(null);\n  }\n};\n```\n\n**But wait**, there's more!\nSee\n\n* [example/challenge-store.js](https://github.com/Daplie/letiny-core/blob/master/challenge-store.js)\n* [example/cert-store.js](https://github.com/Daplie/letiny-core/blob/master/cert-store.js)\n\n## Authors\n\n  * ISRG\n  * Anatol Sommer  (https://github.com/anatolsommer)\n  * AJ ONeal <aj@daplie.com> (https://daplie.com)\n\n## Licence\n\nMPL 2.0\n\nAll of the code is available under the MPL-2.0.\n\nSome of the files are original work not modified from `letiny`\nand are made available under MIT as well (check file headers).\n",
  "readmeFilename": "README.md",
  "_id": "letiny-core@1.0.5",
  "dist": {
    "shasum": "6e9c17f0871a4296c2da75551e205fbc0fcf7302"
  },
  "_from": "letiny-core@^1.0.5",
  "_resolved": "https://registry.npmjs.org/letiny-core/-/letiny-core-1.0.5.tgz"
}
