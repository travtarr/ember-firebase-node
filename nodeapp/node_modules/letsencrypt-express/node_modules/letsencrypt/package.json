{
  "name": "letsencrypt",
  "version": "1.4.3",
  "description": "Let's Encrypt for node.js on npm",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Daplie/node-letsencrypt.git"
  },
  "keywords": [
    "letsencrypt",
    "letsencrypt.org",
    "le",
    "Let's Encrypt",
    "lejs",
    "le.js",
    "acme",
    "node",
    "nodejs",
    "node.js",
    "client"
  ],
  "author": {
    "name": "AJ ONeal",
    "email": "coolaj86@gmail.com",
    "url": "https://coolaj86.com/"
  },
  "license": "(MIT OR Apache-2.0)",
  "bugs": {
    "url": "https://github.com/Daplie/node-letsencrypt/issues"
  },
  "homepage": "https://github.com/Daplie/node-letsencrypt#readme",
  "devDependencies": {
    "express": "^4.13.3",
    "localhost.daplie.com-certificates": "^1.1.2"
  },
  "optionalDependencies": {},
  "dependencies": {
    "bluebird": "^3.0.6",
    "homedir": "^0.6.0",
    "letiny-core": "^1.0.5",
    "mkdirp": "^0.5.1",
    "pyconf": "^1.1.2",
    "request": "^2.67.0",
    "safe-replace": "^1.0.2"
  },
  "readme": "letsencrypt\n===========\n\nAutomatic [Let's Encrypt](https://letsencrypt.org) HTTPS Certificates for node.js\n\n  * [Automatic HTTPS with ExpressJS](https://github.com/Daplie/letsencrypt-express)\n  * [Automatic live renewal](https://github.com/Daplie/letsencrypt-express#how-automatic)\n  * On-the-fly HTTPS certificates for Dynamic DNS (in-process, no server restart)\n  * Works with node cluster out of the box\n  * usable [via commandline](https://github.com/Daplie/letsencrypt-cli) as well\n  * Free SSL (HTTPS Certificates for TLS)\n  * [90-day certificates](https://letsencrypt.org/2015/11/09/why-90-days.html)\n\n**See Also**\n\n* See the node-letsencrypt [Examples](https://github.com/Daplie/node-letsencrypt/tree/master/examples)\n* [Let's Encrypt in (exactly) 90 seconds with Caddy](https://daplie.com/articles/lets-encrypt-in-literally-90-seconds/)\n* [lego](https://github.com/xenolf/lego): Let's Encrypt for golang\n\nInstall\n=======\n\n```bash\nnpm install --save letsencrypt\nnpm install --global letsencrypt-cli\n```\n\nUsage\n=====\n\n### letsencrypt-cli\n\nSee more at [letsencrypt-cli](https://github.com/Daplie/node-letsencrypt-cli)\n\n```bash\nletsencrypt certonly \\\n  --agree-tos --email user@example.com \\\n  --standalone \\\n  --domains example.com,www.example.com \\\n  --config-dir ~/letsencrypt/etc \\\n  --server https://acme-staging.api.letsencrypt.org/directory \\\n\nls ~/letsencrypt/etc/live\n```\n\n### letsencrypt-express\n\n```javascript\n'use strict';\n\n// Note: using staging server url, remove .testing() for production\nvar lex = require('letsencrypt-express').testing();\nvar express = require('express');\nvar app = express();\n\napp.use('/', function (req, res) {\n  res.send({ success: true });\n});\n\nlex.create('./letsencrypt.config', app).listen([80], [443, 5001], function () {\n  console.log(\"ENCRYPT __ALL__ THE DOMAINS!\");\n});\n```\n\nSee more at [letsencrypt-express](https://github.com/Daplie/letsencrypt-express)\n\n### letsencrypt (the library)\n\nThere are **NO DEFAULTS**. A number of **constants** (such as LE.stagingServerUrl and LE.configDir)\nare exported for your convenience, but all required options must be specified by the library invoking the call.\n\nOpen an issue if you need a variable for something that isn't there yet.\n\n```javascript\nvar LE = require('letsencrypt');\n\n\nvar config = {\n, server: LE.stagingServerUrl                               // or LE.productionServerUrl\n\n, configDir: require('homedir')() + '/letsencrypt/etc'      // or /etc/letsencrypt or wherever\n\n, privkeyPath: ':config/live/:hostname/privkey.pem'         //\n, fullchainPath: ':config/live/:hostname/fullchain.pem'     // Note: both that :config and :hostname\n, certPath: ':config/live/:hostname/cert.pem'               //       will be templated as expected\n, chainPath: ':config/live/:hostname/chain.pem'             //\n\n, debug: false\n};\n\n\nvar handlers = {\n  setChallenge: function (opts, hostname, key, val, cb) {}  // called during the ACME server handshake, before validation\n, removeChallenge: function (opts, hostname, key, cb) {}    // called after validation on both success and failure\n, getChallenge: function (opts, hostname, key, cb) {}       // this is special because it is called by the webserver\n                                                            // (see letsencrypt-cli/bin & letsencrypt-express/standalone),\n                                                            // not by the library itself\n\n, agreeToTerms: function (tosUrl, cb) {}                    // gives you an async way to expose the legal agreement\n                                                            // (terms of use) to your users before accepting\n};\n\n\nvar le = LE.create(config, handlers);\n\n                                                              // checks :conf/renewal/:hostname.conf\nle.register({                                                 // and either renews or registers\n\n  domains: ['example.com']                                    // CHANGE TO YOUR DOMAIN\n, email: 'user@email.com'                                     // CHANGE TO YOUR EMAIL\n, agreeTos: false                                             // set to true to automatically accept an agreement\n                                                              // which you have pre-approved (not recommended)\n}, function (err) {\n\n  if (err) {\n    // Note: you must have a webserver running\n    // and expose handlers.getChallenge to it\n    // in order to pass validation\n    // See letsencrypt-cli and or letsencrypt-express\n    console.error('[Error]: node-letsencrypt/examples/standalone');\n    console.error(err.stack);\n  } else {\n    console.log('success');\n  }\n});\n```\n\n**However**, due to the nature of what this library does, it has a few more \"moving parts\"\nthan what makes sense to show in a minimal snippet.\n\nExamples\n========\n\nThe simplest example of setting up a webserver appropriately is probably `letsencrypt-cli` (~120 lines of code):\n\n* [letsencrypt-cli//lib/standalone.js](https://github.com/Daplie/node-letsencrypt-cli/blob/master/lib/standalone.js)\n\nSimilary, `letsencrypt-cli`'s usage of `le.register()` is fairly simple (~75 lines of code):\n\n* [letsencrypt-cli/bin/letsencrypt.js](https://github.com/Daplie/node-letsencrypt-cli/blob/master/bin/letsencrypt.js)\n\n### One-Time Registration\n\nRegister a 90-day certificate manually, on a whim\n\n**Note**: We've been running a fast development cycle and this example may be out of date.\nThe API *shouldn't* have changed much but, we probably need to come back and update it.\n\n#### Snippets\n\n[`commandline-minimal`](https://github.com/Daplie/node-letsencrypt/blob/master/examples/commandline-minimal.js):\n\n**Part 1: the Let's Encrypt client**:\n```javascript\n'use strict';\n\nvar LE = require('letsencrypt');\nvar config = require('./config-minimal');\n\n// Note: you should make this special dir in your product and leave it empty\nconfig.le.webrootPath = __dirname + '/../tests/acme-challenge';\nconfig.le.server = LE.stagingServer;\n\n\n//\n// Manual Registration\n//\nvar le = LE.create(config.backend, config.le);\nle.register({\n  agreeTos: true\n, domains: ['example.com']          // CHANGE TO YOUR DOMAIN\n, email: 'user@email.com'           // CHANGE TO YOUR EMAIL\n}, function (err) {\n  if (err) {\n    console.error('[Error]: node-letsencrypt/examples/standalone');\n    console.error(err.stack);\n  } else {\n    console.log('success');\n  }\n\n  plainServer.close();\n  tlsServer.close();\n});\n```\n\n**Part 2: Express Web Server**:\n```javascript\n//\n// Express App\n//\nvar app = require('express')();\napp.use('/', le.middleware());  // TODO le.middleware was moved to letsencrypt-express, we need to update the docs here\n\n\n//\n// HTTP & HTTPS servers\n// (required for domain validation)\n//\nvar plainServer = require('http').createServer(app).listen(config.plainPort, function () {\n  console.log('Listening http', this.address());\n});\n\nvar tlsServer = require('https').createServer({\n  key: config.tlsKey\n, cert: config.tlsCert\n, SNICallback: le.sniCallback\n}, app).listen(config.tlsPort, function () {\n  console.log('Listening http', this.address());\n});\n```\n\n#### Runnable Demo\n\n* [commandline (standalone with \"webroot\")](https://github.com/Daplie/node-letsencrypt/blob/master/examples/commandline.js)\n\n```bash\n# manual standalone registration via commandline\n# (runs against testing server on tls port 5001)\nnode examples/commandline.js example.com,www.example.com user@example.net agree\n```\n\n### Express\n\nFully Automatic HTTPS with ExpressJS using Free SSL certificates from Let's Encrypt\n\n#### Snippets\n\n* [Minimal ExpressJS Example](https://github.com/Daplie/node-letsencrypt/blob/master/examples/express-minimal.js)\n\n```javascript\n'use strict';\n\nvar LE = require('letsencrypt');\nvar config = require('./config-minimal');\n\n// Note: you should make this special dir in your product and leave it empty\nconfig.le.webrootPath = __dirname + '/../tests/acme-challenge';\nconfig.le.server = LE.stagingServer;\n\n//\n// Automatically Register / Renew Domains\n//\nvar le = LE.create(config.backend, config.le, {\n  sniRegisterCallback: function (args, expiredCert, cb) {\n    // Security: check that this is actually a subdomain we allow\n    // (otherwise an attacker can cause you to rate limit against the LE server)\n\n    var hostname = args.domains[0];\n    if (!/\\.example\\.com$/.test(hostname)) {\n      console.error(\"bad domain '\" + hostname + \"', not a subdomain of example.com\");\n      cb(nul, null);\n    }\n\n    // agree to the LE TOS for this domain\n    args.agreeTos = true;\n    args.email = 'user@example.com';\n\n    // use the cert even though it's expired\n    if (expiredCert) {\n      cb(null, expiredCert);\n      cb = function () { /*ignore*/ };\n    }\n\n    // register / renew the certificate in the background\n    le.register(args, cb);\n  }\n});\n\n\n//\n// Express App\n//\nvar app = require('express')();\napp.use('/', le.middleware());\n\n\n//\n// HTTP & HTTPS servers\n//\nrequire('http').createServer(app).listen(config.plainPort, function () {\n  console.log('Listening http', this.address());\n});\n\nrequire('https').createServer({\n  key: config.tlsKey\n, cert: config.tlsCert\n, SNICallback: le.sniCallback\n}, app).listen(config.tlsPort, function () {\n  console.log('Listening http', this.address());\n});\n```\n\n#### Runnable Example\n\n* [Full ExpressJS Example](https://github.com/Daplie/node-letsencrypt/blob/master/examples/express.js)\n\n```bash\n# clear out the certificates\nrm -rf tests/letsencrypt.*\n\n# automatic registration and renewal (certs install as you visit the site for the first time)\n# (runs against testing server on tls port 5001)\nnode examples/express.js example.com,www.example.com user@example.net agree\n```\n\n```bash\n# this will take a moment because it won't respond to the tls sni header until it gets the certs\ncurl https://example.com/\n```\n\n### non-root\n\nIf you want to run this as non-root, you can.\n\nYou just have to set node to be allowed to use root ports\n\n```\n# node\nsudo setcap cap_net_bind_service=+ep /usr/local/bin/node\n```\n\nand then make sure to set all of of the following to a directory that your user is permitted to write to\n\n* `webrootPath`\n* `configDir`\n\n\nAPI\n===\n\n```javascript\nLetsEncrypt.init(leConfig, handlers)                      // wraps a given\nLetsEncrypt.create(backend, leConfig, handlers)           // wraps a given \"backend\" (the python or node client)\nLetsEncrypt.stagingServer                                 // string of staging server for testing\n\nle.middleware()                                           // middleware for serving webrootPath to /.well-known/acme-challenge\nle.sniCallback(hostname, function (err, tlsContext) {})   // uses fetch (below) and formats for https.SNICallback\nle.register({ domains, email, agreeTos, ... }, cb)        // registers or renews certs for a domain\nle.fetch({domains, email, agreeTos, ... }, cb)            // fetches certs from in-memory cache, occasionally refreshes from disk\nle.validate(domains, cb)                                  // do some sanity checks before attempting to register\nle.registrationFailureCallback(err, args, certInfo, cb)   // called when registration fails (not implemented yet)\n```\n\n### `LetsEncrypt.create(backend, leConfig, handlers)`\n\n#### leConfig\n\nThe arguments passed here (typically `webpathRoot`, `configDir`, etc) will be merged with\nany `args` (typically `domains`, `email`, and `agreeTos`) and passed to the backend whenever\nit is called.\n\nTypically the backend wrapper will already merge any necessary backend-specific arguments.\n\n**Example**:\n```javascript\n{ webrootPath: __dirname, '/acme-challenge'\n, fullchainTpl: '/live/:hostname/fullchain.pem'\n, privkeyTpl: '/live/:hostname/fullchain.pem'\n, configDir: '/etc/letsencrypt'\n}\n```\n\nNote: `webrootPath` can be set as a default, semi-locally with `webrootPathTpl`, or per\nregistration as `webrootPath` (which overwrites `leConfig.webrootPath`).\n\n#### handlers *optional*\n\n`h.setChallenge(hostnames, name, value, cb)`:\n\ndefault is to write to fs\n\n`h.getChallenge(hostnames, value cb)`\n\ndefault is to read from fs\n\n`h.sniRegisterCallback(args, currentCerts, cb)`\n\nThe default is to immediately call `cb(null, null)` and register (or renew) in the background\nduring the `SNICallback` phase. Right now it isn't reasonable to renew during SNICallback,\nbut around February when it is possible to use ECDSA keys (as opposed to RSA at present),\nregistration will take very little time.\n\nThis will not be called while another registration is already in progress.\n\n**SECURITY WARNING**: If you use this option with a custom `h.validate()`, make sure that `args.domains`\nrefers to domains you expect, otherwise an attacker will spoof SNI and cause your server to rate-limit\nletsencrypt.org and get blocked. Note that `le.validate()` will check A records before attempting to\nregister to help prevent such possible attacks.\n\n`h.validate(domains, cb)`\n\nWhen specified this will override `le.validate()`. You will need to do this if the ip address of this\nserver is not one specified in the A records for your domain.\n\n### `le.middleware()`\n\nAn express handler for `/.well-known/acme-challenge/<challenge>`.\nWill call `getChallenge([hostname], key, cb)` if present or otherwise read `challenge` from disk.\n\nExample:\n```javascript\napp.use('/', le.middleware())\n```\n\n### `le.sniCallback(hostname, function (err, tlsContext) {});`\n\nWill call `fetch`. If fetch does not return certificates or returns expired certificates\nit will call `sniRegisterCallback(args, currentCerts, cb)` and then return the error,\nthe new certificates, or call `fetch` a final time.\n\nExample:\n```javascript\nvar server = require('https').createServer({ SNICallback: le.sniCallback, cert: '...', key: '...' });\nserver.on('request', app);\n```\n\n### `le.register({ domains, email, agreeTos, ... }, cb)`\n\nGet certificates for a domain\n\nExample:\n```javascript\nle.register({\n  domains: ['example.com', 'www.example.com']\n, email: 'user@example.com'\n, webrootPath: '/srv/www/example.com/public'\n, agreeTos: true\n}, function (err, certs) {\n  // err is some error\n\n  console.log(certs);\n  /*\n  { cert: \"contents of fullchain.pem\"\n  , key: \"contents of privkey.pem\"\n  , renewedAt: <date in milliseconds>\n  , duration: <duration in milliseconds (90-days)>\n  }\n  */\n});\n```\n\n### `le.isValidDomain(hostname)`\n\nreturns `true` if `hostname` is a valid ascii or punycode domain name.\n\n(also exposed on the main exported module as `LetsEncrypt.isValidDomain()`)\n\n### `le.validate(args, cb)`\n\nUsed internally, but exposed for convenience. Checks `LetsEncrypt.isValidDomain()`\nand then checks to see that the current server\n\nCalled before `backend.register()` to validate the following:\n\n  * the hostnames don't use any illegal characters\n  * the server's actual public ip (via api.apiify.org)\n  * the A records for said hostnames\n\n### `le.fetch(args, cb)`\n\nUsed internally, but exposed for convenience.\n\nChecks in-memory cache of certificates for `args.domains` and calls then calls `backend.fetch(args, cb)`\n**after** merging `args` if necessary.\n\n### `le.registrationFailureCallback(err, args, certInfo, cb)`\n\nNot yet implemented\n\n\nThis is what `args` looks like:\n\n```javascript\n{ domains: ['example.com', 'www.example.com']\n, email: 'user@email.com'\n, agreeTos: true\n, configDir: '/etc/letsencrypt'\n, fullchainTpl: '/live/:hostname/fullchain.pem'  // :hostname will be replaced with the domainname\n, privkeyTpl: '/live/:hostname/privkey.pem'\n, webrootPathTpl: '/srv/www/:hostname/public'\n, webrootPath: '/srv/www/example.com/public'    // templated from webrootPathTpl\n}\n```\n\nThis is what the implementation should look like:\n\n(it's expected that the client will follow the same conventions as\nthe python client, but it's not necessary)\n\nChange History\n==============\n\n* v1.1.0 Added letiny-core, removed node-letsencrypt-python\n* v1.0.2 Works with node-letsencrypt-python\n* v1.0.0 Thar be dragons\n\nLICENSE\n=======\n\nDual-licensed MIT and Apache-2.0\n\nSee LICENSE\n",
  "readmeFilename": "README.md",
  "_id": "letsencrypt@1.4.3",
  "dist": {
    "shasum": "c07f40bd5996a40508268423ccdf000f018c49bf"
  },
  "_from": "letsencrypt@^1.4.2",
  "_resolved": "https://registry.npmjs.org/letsencrypt/-/letsencrypt-1.4.3.tgz"
}
